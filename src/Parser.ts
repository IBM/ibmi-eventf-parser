/*
 * (c) Copyright IBM Corp. 2023
 */

import { IRecordT } from './record/IRecordT';
import { TimestampRecord } from './record/TimestampRecord';
import { ProcessorRecord } from './record/ProcessorRecord';
import { FileIDRecord } from './record/FileIDRecord';
import { IProcessor } from './IProcessor';
import { ISequentialFileReader } from './ISequentialFileReader';
import { IMarkerCreator } from './IMarkerCreator';
import { ErrorInformationRecord } from './record/ErrorInformationRecord';
import { FileEndRecord } from './record/FileEndRecord';
import { ExpansionRecord } from './record/ExpansionRecord';
import { ExpansionProcessor } from './ExpansionProcessor';
import normalize from 'path-normalize';

class SourceFile {
  constructor(private location: string, private browseMode: boolean) { }

  public getLocation(): string {
    return this.location;
  }

  public isReadOnly(): string {
    return this.browseMode.toString();
  }

  public setReadOnly(value: boolean) {
    // A member should be opened in browse mode
    this.browseMode = value;
  }
}

class LookAheadReader implements ISequentialFileReader {
  private iSequentialFileReader: ISequentialFileReader;
  private peakLine: string | undefined;

  constructor(iSequentialFileReader: ISequentialFileReader) {
    this.iSequentialFileReader = iSequentialFileReader;
  }

  readNextLine(): string | undefined {
    if (this.peakLine) {
      const nextLine = this.peakLine;
      this.peakLine = undefined;

      return nextLine;
    } else {
      return this.iSequentialFileReader.readNextLine();
    }
  }

  peakNextRecordType() {
    this.peakLine = this.iSequentialFileReader.readNextLine();
    return this.peakLine?.split(/\s+/).filter(token => token !== "")[0];
  }
}

export class Parser {
  private _loggingEnabled: boolean = false;
  private exception: Error | undefined;
  private processor: IProcessor | undefined;
  private lastOutputFile: SourceFile | undefined;
  private currentOutputFile: SourceFile | undefined;

  // Map of File ID to SourceFile
  private sourceTable: Map<number, SourceFile>;

  constructor() {
    this.sourceTable = new Map<number, SourceFile>();
  }

  private getUntilTheEndOfTheLine(startIndex: number, st: string[]): string {
    let message = st[startIndex++];
    while (startIndex < st.length) {
      message = message.concat(' ');
      let curr_msg = st[startIndex++];
      message = message.concat(curr_msg);
    }
    return message;
  }

  /**
   * Enable or disable logging.
   *
   * @param {boolean} enable true to enable or false to disable logging
   */
  loggingEnabled(enable: boolean) {
    this._loggingEnabled = enable;
  }

  private log(content: string) {
    if (this._loggingEnabled) {
      console.log(content);
    }
  }

  /**
   * To parse an eventf generated by an IBM i compiler.  
   * @param fileReader a generic reader implementing {@link ISequentialFileReader}. 
   * @param markerCreator optionally passing in an object implementing {@link IMarkerCreator}
   *   allows the parser to call this object back with each error.  The original source
   *   file name and error location and error message will be in the information provided
   *   on the callback
   */
  parse(fileReader: ISequentialFileReader, markerCreator?: IMarkerCreator) {
    let word: string;
    let fileId: number;

    if (!this.processor) {
      this.processor = new ExpansionProcessor();
    }
    // Allows processor to initialize prior to parsing
    this.processor?.doPreProcessing();

    const reader = new LookAheadReader(fileReader);
    let lineText = reader.readNextLine();

    while (lineText) {
      let st = lineText.split(/\s+/).filter(token => token !== "");
      let i = 0

      while (i < st.length) {
        word = st[i++];

        if (word === IRecordT.ERROR_INFORMATION) {
          const version = parseInt(st[i++]);
          fileId = parseInt(st[i++]);

          let fileProcessed = this.sourceTable.get(fileId);
          if (!fileProcessed) {
            // If file ID is '000' we can assume that it is the second file after the '999' output file
            if (fileId === 0) {
              let location001 = this.sourceTable.get(1);
              if (location001) {
                fileProcessed = location001;
              } else {
                fileProcessed = new SourceFile('', false);
              }
            } else {
              fileProcessed = new SourceFile('', false);
            }
          }

          const annotationClass = parseInt(st[i++]);
          const line = parseInt(st[i++]);
          const lineStart = parseInt(st[i++]);
          const charStart = parseInt(st[i++]);
          const lineEnd = parseInt(st[i++]);
          const charEnd = parseInt(st[i++]);
          const id = st[i++];
          const severityText = st[i++];
          const severity = parseInt(st[i++]);

          const totalMessageLen = parseInt(st[i++]);
          const message = this.getUntilTheEndOfTheLine(i, st);

          // Previous implementation used the location length to determine how many records to 
          // read in.  This requires NLS process to account for differences in character length 
          // between the encoding in the original EVENTF and the current one being parsed.
          // To avoid this, we simply read all subsequent records that are of the continued type
          //
          // let msgToken = st.nextToken('\n\r\f');
          // let msgTokenNl = new StringNL(msgToken, ccsid, true);

          // msgTokenNl = msgTokenNl.trim();
          // message = msgTokenNl.convertFromVisualToLogical(true);
          // let messageLenCorrect = true;
          // if (msgTokenNl.getByteLength() > totalMessageLen) {
          //   message = msgTokenNl.substring(0, totalMessageLen).convertFromVisualToLogical(true);
          // } else {
          //   while ((msgTokenNl.getByteLength() < totalMessageLen) && messageLenCorrect) {
          //     lineText = reader.readNextLine();
          //     if (lineText === null) {
          //       let log = 'EventsFileParser: ' + MessageFormat.format(Messages.EventsFileParser_Incomplete_Msg, totalMessageLen, totalMessageLen, message);
          //       this.LOGGER.info(log);
          //       messageLenCorrect = false;
          //       msgToken = '';
          //       break;
          //     }
          //     let stcont = new StringTokenizer(lineText);
          //     msgToken = stcont.nextToken('\n\r\f');
          //     msgTokenNl = new StringNL(msgToken, ccsid, true);
          //     stcont = new StringTokenizer(msgToken);
          //     let lineType = stcont.get(i++);
          //     if (lineType === (RecordType.TIMESTAMP) || lineType === (RecordType.PROCESSOR) || lineType === (RecordType.FILE_ID) || lineType === (RecordType.FILE_CONT) || lineType === (RecordType.FILE_END) || lineType === (RecordType.ERROR_INFORMATION) || lineType === (RecordType.PROGRAM) || lineType === (RecordType.MAP_DEFINE) || lineType === (RecordType.MAP_END) || lineType === (RecordType.MAP_START) || lineType === (RecordType.FEEDBACK_CODE)) {
          //       messageLenCorrect = false;
          //       break;
          //     }
          //     readMsgLen += msgTokenNl.getByteLength();
          //     message += ' ' + msgTokenNl.trim().convertFromVisualToLogical(true);
          //   }
          // }

          const record = new ErrorInformationRecord(version, fileId, annotationClass, line, lineStart, charStart,
            lineEnd, charEnd, id, severityText, severity, totalMessageLen, message);
          record.setFileName(fileProcessed.getLocation());

          if (this.processor) {
            this.processor.processErrorRecord(record);
          }

          // if (!messageLenCorrect) {
          //   st = new StringTokenizer(msgToken);
          //   st = msgToken.split(" ")
          //   continue;
          // }

          break;
        } else if (word === (IRecordT.FILE_ID)) {
          let browseMode = false;
          const version = parseInt(st[i++]);
          fileId = parseInt(st[i++]);
          const lineNumber = parseInt(st[i++]);
          const locationLength = parseInt(st[i++]);
          let location = lineText.substring(28);

          this.log(`EventsFileParser: location from line 1 = ${location}`);
          let nextRecordType = reader.peakNextRecordType();
          while (nextRecordType === IRecordT.FILE_CONT) {
            lineText = reader.readNextLine();
            if (lineText) {
              st = lineText.split(' ');
              location += (lineText.substring(28));
              this.log(`EventsFileParser: location from line 1 = ${location}`);
              nextRecordType = reader.peakNextRecordType();
            } else {
              throw new Error('Events file has incorrect format. End of file encountered before location length satisfied.');
            }
          }

          // Attempt to parse the FILEID string backwards in order to find the timestamp and temp flag
          // Timestamp should only be made of digits if it was parsed correctly. Otherwise, just ignore it.
          let timestamp = location.substring(location.length - 16, location.length - 2);
          try {
            parseInt(timestamp);
          } catch (e: any) {
            timestamp = '';
          }
          const tempFlag = parseInt(location.charAt(location.length - 1));

          // Makes sure that the Temp Flag is the last character in the FILEID event and that it is preceded by a space
          const isSpaceBeforeTempFlag = location.charAt(location.length - 2) === ' ';
          if (tempFlag === 1 && isSpaceBeforeTempFlag) {
            browseMode = true;
          } else {
            browseMode = false;
          }

          location = location.substring(0, location.length - 17);
          location = this.resolveRelativePath(location);

          // If this file was the output file of the previous block, then it should be opened in Browse Mode
          const fileEntry = new SourceFile(location, browseMode);
          if ((this.lastOutputFile && location === (this.lastOutputFile.getLocation()))
            || this.currentOutputFile && location === (this.currentOutputFile.getLocation())) {
            fileEntry.setReadOnly(true);
          }

          // If the file ID is 999, then this is the new output file
          if (fileId === 999) {
            if (!this.lastOutputFile) {
              this.lastOutputFile = this.currentOutputFile = fileEntry;
            } else {
              this.lastOutputFile = this.currentOutputFile;
              this.currentOutputFile = fileEntry;
            }
          }

          this.sourceTable.set(fileId, fileEntry);

          if (this.processor) {
            // Pass FILEID information to processor
            const record = new FileIDRecord(version, fileId, lineNumber, locationLength, location, timestamp.toString(), tempFlag);
            try {
              this.processor.processFileIDRecord(record);
            } catch (e: any) {
              const errorMessage = e.message ? e.message : e;
              this.log(errorMessage);
              this.exception = new Error(errorMessage);
            }
          }

          break;
        } else if (word === (IRecordT.FILE_END)) {
          // Pass FILEEND information to processor
          if (this.processor) {
            const version = parseInt(st[i++]);
            const fileId = parseInt(st[i++]);
            const expansion = parseInt(st[i++]);
            const record = new FileEndRecord(version, fileId, expansion);

            try {
              this.processor?.processFileEndRecord(record);
            } catch (e: any) {
              const errorMessage = e.message ? e.message : e;
              this.log(errorMessage);
              this.exception = new Error(errorMessage);
            }
          }

          break;
        } else if (word === (IRecordT.EXPANSION)) {
          // Pass EXPANSION information to processor
          if (this.processor) {
            const version = parseInt(st[i++]);
            const inputFileID = parseInt(st[i++]);
            const inputLineStart = parseInt(st[i++]);
            const inputLineEnd = parseInt(st[i++]);
            const outputFileID = parseInt(st[i++]);
            const outputLineStart = parseInt(st[i++]);
            const outputLineEnd = parseInt(st[i++]);
            const record = new ExpansionRecord(version, inputFileID, inputLineStart, inputLineEnd, outputFileID, outputLineStart, outputLineEnd);
            this.processor?.processExpansionRecord(record);
          }

          break;
        } else if (word === (IRecordT.TIMESTAMP)) {
          // Pass TIMESTAMP information to processor
          if (this.processor) {
            const version = parseInt(st[i++]);
            const timestamp = st[i++];
            let record = new TimestampRecord(version, timestamp);
            this.processor?.processTimestampRecord(record);
          }

          break;
        } else if (word === (IRecordT.PROCESSOR)) {
          // Pass PROCESSOR information to processor
          if (this.processor) {
            const version = parseInt(st[i++]);
            const outputId = parseInt(st[i++]);
            const lineClass = parseInt(st[i++]);
            let record = new ProcessorRecord(version, outputId, lineClass);

            try {
              this.processor?.processProcessorRecord(record);
            } catch (e: any) {
              const errorMessage = e.message ? e.message : e;
              this.log(errorMessage);
              this.exception = new Error(errorMessage);
            }
          }

          break;
        } else {
          // The following Events are being ignored since they are not used.
          // If needed, we could parse those Events and pass them to an IISeriesEventsFileProcessor.
          if (word === (IRecordT.PROGRAM) || word === (IRecordT.MAP_DEFINE) || word === (IRecordT.MAP_END)
            || word === (IRecordT.MAP_START) || word === (IRecordT.FEEDBACK_CODE) || word.trim().length === 0) {
            break;
          } else {
            throw new Error(`Events file has incorrect format. Unexpected line type. LT=${lineText}`);
          }
        }
      }

      if (lineText) {
        lineText = reader.readNextLine();
      }
    }

    if (this.processor) {
      // Allows processor to consume the information after completion of parsing and writing of markers
      try {
        this.processor?.doPostProcessing();
      } catch (e: any) {
        this.exception = new Error(e.message ? e.message : e)
      }
    }

    if (markerCreator) {
      const errors = this.getAllErrors();
      errors.forEach(record => {
        const sourceFile = this.sourceTable.get(record.getFileId());

        if (sourceFile) {
          markerCreator.createMarker(record, record.getFileName(), sourceFile.isReadOnly());
        }
      });
    }
  }

  private resolveRelativePath(location: string) {
    // Normalize the location in case the location is a relative path
    location = normalize(location).toString();

    // After normalization, / will be change to \ for windows path,
    // so have to change it back.
    location = location.replace(/\\/g, '/');
    return location;
  }

  public getException(): Error | undefined {
    return this.exception;
  }

  public setProcessor(processor: IProcessor) {
    this.processor = processor;
  }

  /**
   * After all records in the Events File are processed, this method is called to
   * return all the errors from all the processor blocks (ProcessorBlock) of the
   * Events File. Since each ProcessorBlock contains an array of errors, the result
   * will be flattened to an array.
   * 
   * @return An array of all parsed errors from all processor blocks of the Events File.
   */
  public getAllErrors(): ErrorInformationRecord[] {
    if (this.processor) {
      const nestedErrors = this.processor?.getAllErrors();
      let allErrors: ErrorInformationRecord[] = [];
      allErrors = allErrors.concat(...nestedErrors);

      return allErrors;
    } else {
      return [];
    }
  }

  /**
   * Get all file ID records.
   * 
   * @return An array of all file ID records.
   */
  public getAllFileIDRecords(): FileIDRecord[] {
    if (this.processor) {
      return this.processor.getAllFileIDRecords();
    } else {
      return [];
    }
  }
}